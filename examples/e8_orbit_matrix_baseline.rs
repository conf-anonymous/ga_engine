//! E8 Orbit Enumeration - Matrix Baseline
//!
//! Benchmark orbit enumeration using standard matrix reflections.
//!
//! This is the BASELINE for comparison against GA rotor approach.

use ga_engine::lattice_reduction::e8_lattice::{E8Lattice, reflect_vector, norm_squared};
use std::collections::HashSet;
use std::time::Instant;

/// Hash wrapper for [f64; 8] vectors
#[derive(Clone, Copy, Debug)]
struct FloatVec([f64; 8]);

impl PartialEq for FloatVec {
    fn eq(&self, other: &Self) -> bool {
        self.0.iter().zip(other.0.iter()).all(|(a, b)| (a - b).abs() < 1e-10)
    }
}

impl Eq for FloatVec {}

impl std::hash::Hash for FloatVec {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        for &x in &self.0 {
            let rounded = (x * 1e10).round() as i64;
            rounded.hash(state);
        }
    }
}

/// Enumerate orbit of v under reflections generated by simple_roots
///
/// Uses standard matrix-based reflection: r_α(v) = v - 2⟨v,α⟩/⟨α,α⟩ · α
fn enumerate_orbit_matrix(v: &[f64; 8], simple_roots: &[[f64; 8]], max_orbit_size: usize) -> HashSet<FloatVec> {
    let mut orbit = HashSet::new();
    orbit.insert(FloatVec(*v));

    let mut prev_size = 0;
    let mut iteration = 0;

    while orbit.len() != prev_size && orbit.len() < max_orbit_size {
        prev_size = orbit.len();
        iteration += 1;

        let current_vectors: Vec<[f64; 8]> = orbit.iter().map(|fv| fv.0).collect();

        for vec in current_vectors {
            for root in simple_roots {
                let reflected = reflect_vector(&vec, root);
                orbit.insert(FloatVec(reflected));

                if orbit.len() >= max_orbit_size {
                    break;
                }
            }
        }

        if iteration % 5 == 0 {
            println!("  Iteration {}: {} vectors in orbit", iteration, orbit.len());
        }
    }

    orbit
}

fn main() {
    println!("╔══════════════════════════════════════════════════════════╗");
    println!("║  E8 Orbit Enumeration - Matrix Baseline                 ║");
    println!("╚══════════════════════════════════════════════════════════╝");
    println!();

    let e8 = E8Lattice::new();
    println!("{}", e8);
    println!();

    // Test vectors
    let test_vectors = vec![
        ("e₁", [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),
        ("e₁+e₂", [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),
        ("highest root", [1.0, 2.0, 3.0, 2.0, 1.0, 2.0, 0.0, 0.0]),
    ];

    for (name, test_vec) in test_vectors {
        println!("──────────────────────────────────────────────────────────");
        println!("Test vector: {}", name);
        println!("  v = {:?}", &test_vec[..4]);
        println!("  ||v||² = {:.6}", norm_squared(&test_vec));
        println!();

        // Limit orbit size to avoid running forever
        let max_orbit = 1000;

        println!("Enumerating orbit (matrix reflections)...");
        let start = Instant::now();

        let orbit = enumerate_orbit_matrix(&test_vec, e8.simple_roots(), max_orbit);

        let elapsed = start.elapsed();

        println!();
        println!("Results:");
        println!("  Orbit size: {}", orbit.len());
        println!("  Time: {:?}", elapsed);
        println!("  Time per vector: {:?}", elapsed / orbit.len() as u32);
        println!();

        // Verify all orbit vectors have same norm
        let original_norm_sq = norm_squared(&test_vec);
        let mut all_same_norm = true;
        for vec in orbit.iter().take(10) {
            let norm_sq = norm_squared(&vec.0);
            if (norm_sq - original_norm_sq).abs() > 1e-8 {
                println!("  ⚠️  Norm not preserved: {} vs {}", norm_sq, original_norm_sq);
                all_same_norm = false;
            }
        }
        if all_same_norm {
            println!("  ✓ All orbit vectors have same norm (checked {} samples)", orbit.len().min(10));
        }
    }

    println!("──────────────────────────────────────────────────────────");
    println!();
    println!("Baseline matrix approach established.");
    println!("Next: Compare against GA rotor approach.");
}
